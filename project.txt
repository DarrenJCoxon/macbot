// types/pdf-parse.d.ts
declare module 'pdf-parse' {
    interface PDFData {
      text: string;
      numpages: number;
      numrender: number;
      info: {
        PDFFormatVersion: string;
        IsAcroFormPresent: boolean;
        IsXFAPresent: boolean;
        [key: string]: unknown;
      };
      metadata: unknown;
      version: string;
    }
  
    interface PDFOptions {
      pagerender?: (pageData: unknown) => string;
      max?: number;
    }
  
    function parse(dataBuffer: Buffer, options?: PDFOptions): Promise<PDFData>;
    
    namespace parse {
      export { parse };
    }
    
    export = parse;
  }// app/types/index.ts

// Message Types
export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  createdAt?: Date;
}
  
// Chat History Type
export interface ChatHistory {
  messages: Message[];
}
  
// Together.ai Response Types
export interface TogetherStreamChunk {
  choices: {
    delta: {
      content?: string;
    };
    index: number;
  }[];
}

// Add new types for file handling
export interface UploadedFile {
  id: string;
  name: string;
  contentType: string;
  size: number;
  uploadedAt: Date;
}

export interface FileChunk {
  id: string;
  fileId: string;
  content: string;
  metadata: {
    fileName: string;
    pageNumber?: number;
    chunkIndex: number;
  };
}

export interface VectorSearchResult {
  id: string;
  score: number;
  content: string;
  metadata: {
    fileName: string;
    pageNumber?: number;
    chunkIndex: number;
  };
}// app/admin/page.tsx
'use client';

import React from 'react';
import Link from 'next/link';
import DocumentUploader from '@/app/components/DocumentUploader';
import styled from 'styled-components';

const AdminPageContainer = styled.div`
  padding: 2rem;
  max-width: 900px;
  margin: 2rem auto;
  border: 2px solid ${props => props.theme.colors.border};
  border-radius: ${props => props.theme.borderRadius.medium};
  background-color: ${props => props.theme.colors.background};
  background-image: url('/parchment-bg.png');
  background-size: cover;
  box-shadow: ${props => props.theme.shadows.large};
`;

const AdminPageTitle = styled.h1`
  text-align: center;
  margin-bottom: 2rem;
  font-size: 2.5rem;
  font-weight: 600;
  color: ${props => props.theme.colors.primary};
  font-family: ${props => props.theme.fonts.heading};
  
  &:before, &:after {
    content: '❦';
    margin: 0 1rem;
    color: ${props => props.theme.colors.gold};
  }
`;

const BackLink = styled(Link)`
    display: block;
    margin-bottom: 2rem;
    color: ${props => props.theme.colors.secondary};
    text-decoration: none;
    font-family: ${props => props.theme.fonts.heading};
    font-style: italic;
    
    &:before {
      content: '←';
      margin-right: 0.5rem;
    }
    
    &:hover {
        color: ${props => props.theme.colors.secondaryLight};
        text-decoration: underline;
    }
`;

export default function AdminPage() {
  return (
    <AdminPageContainer>
        <BackLink href="/">Return to the Oracle</BackLink>
        <AdminPageTitle>The Scribe&apos;s Chambers</AdminPageTitle>

        {/* Document Uploader */}
        <DocumentUploader />
    </AdminPageContainer>
  );
}.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
// app/styles/styled.d.ts
import 'styled-components';

// Extend the DefaultTheme interface
declare module 'styled-components' {
  export interface DefaultTheme {
    colors: {
      primary: string;
      primaryLight: string;
      primaryDark: string;
      secondary: string;
      secondaryLight: string;
      secondaryDark: string;
      background: string;
      backgroundDark: string;
      text: string;
      textLight: string;
      gold: string;
      forest: string;
      fog: string;
      error: string;
      success: string;
      border: string;
    };
    
    fonts: {
      heading: string;
      body: string;
      mono: string;
    };
    
    spacing: {
      xs: string;
      sm: string;
      md: string;
      lg: string;
      xl: string;
      xxl: string;
    };
    
    borderRadius: {
      small: string;
      medium: string;
      large: string;
      round: string;
    };
    
    shadows: {
      small: string;
      medium: string;
      large: string;
    };
  }
}// app/styles/ChatStyles.ts
'use client';

import styled from 'styled-components';

// Main container for the entire chat interface
export const ChatContainer = styled.div`
  display: flex;
  flex-direction: column;
  height: 600px;
  border: 1px solid ${props => props.theme?.colors?.border || 'var(--gray-300)'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  overflow: hidden;
  background-color: ${props => props.theme?.colors?.background || 'var(--background)'};
  box-shadow: ${props => props.theme?.shadows?.medium || '0 4px 8px rgba(0, 0, 0, 0.2)'};
  font-family: ${props => props.theme?.fonts?.body || 'inherit'};
  position: relative;
  
  /* Decorative corner flourishes */
  &:before, &:after {
    content: '❦';
    position: absolute;
    color: ${props => props.theme?.colors?.gold || '#c4a747'};
    font-size: 1.5rem;
    opacity: 0.7;
  }
  
  &:before {
    top: 10px;
    left: 10px;
  }
  
  &:after {
    bottom: 10px;
    right: 10px;
  }
`;

// Container for the scrollable list of messages
export const MessagesList = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  background: ${props => props.theme?.colors?.background || 'var(--background)'};
  background-image: linear-gradient(
    rgba(248, 244, 233, 0.7), 
    rgba(248, 244, 233, 0.7)
  );
  
  /* Custom scrollbar for theme */
  &::-webkit-scrollbar {
    width: 8px;
  }
  
  &::-webkit-scrollbar-track {
    background: ${props => props.theme?.colors?.backgroundDark || 'var(--gray-100)'};
  }
  
  &::-webkit-scrollbar-thumb {
    background-color: ${props => props.theme?.colors?.border || 'var(--gray-300)'};
    border-radius: 20px;
  }
`;

// Individual message bubble styling
export const MessageBubble = styled.div<{ $isUser: boolean }>`
  max-width: 80%;
  padding: 12px 16px;
  border-radius: ${props => props.$isUser 
    ? `${props.theme?.borderRadius?.large || '8px'} ${props.theme?.borderRadius?.large || '8px'} 0 ${props.theme?.borderRadius?.large || '8px'}`
    : `${props.theme?.borderRadius?.large || '8px'} ${props.theme?.borderRadius?.large || '8px'} ${props.theme?.borderRadius?.large || '8px'} 0`
  };
  align-self: ${props => (props.$isUser ? 'flex-end' : 'flex-start')};
  
  /* Different styling for user vs assistant */
  background-color: ${props => props.$isUser 
    ? (props.theme?.colors?.primary || 'var(--primary)') 
    : (props.theme?.colors?.backgroundDark || 'var(--gray-200)')
  };
  color: ${props => props.$isUser 
    ? 'white'
    : (props.theme?.colors?.text || 'var(--gray-800)')
  };
  
  /* Parchment effect for the assistant's messages */
  ${props => !props.$isUser && `
    border: 1px solid ${props.theme?.colors?.border || '#d1c4a1'};
    box-shadow: ${props.theme?.shadows?.small || '0 2px 4px rgba(0, 0, 0, 0.1)'};
    position: relative;
    
    &:after {
      content: '';
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, transparent 50%, rgba(209, 196, 161, 0.3) 50%);
      border-radius: 0 0 ${props.theme?.borderRadius?.large || '8px'} 0;
    }
  `}
  
  /* User message styling */
  ${props => props.$isUser && `
    box-shadow: ${props.theme?.shadows?.small || '0 2px 4px rgba(0, 0, 0, 0.1)'};
  `}
  
  /* Markdown elements styling */
  h1, h2, h3, h4, h5, h6 {
    margin-top: 0.8em;
    margin-bottom: 0.4em;
    font-weight: 600;
    line-height: 1.3;
    color: inherit;
    font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
    
    &:first-child {
      margin-top: 0;
    }
  }
  
  h1 { font-size: 1.4em; }
  h2 { font-size: 1.3em; }
  h3 { font-size: 1.2em; }

  p {
    margin-bottom: 0.8em;
    
    &:last-child {
      margin-bottom: 0;
    }
  }
  
  /* Lists */
  ul, ol {
    margin-bottom: 0.8em;
    padding-left: 1.5em;
  }

  li {
    margin-bottom: 0.3em;
  }

  /* Inline Code */
  code {
    background-color: ${props => props.$isUser 
      ? 'rgba(255, 255, 255, 0.2)' 
      : 'rgba(0, 0, 0, 0.08)'
    };
    padding: 0.2em 0.4em;
    border-radius: 4px;
    font-size: 0.9em;
    font-family: ${props => props.theme?.fonts?.mono || 'var(--font-geist-mono, Consolas, Monaco, monospace)'};
  }
  
  /* Code Blocks */
  pre {
    background-color: ${props => props.theme?.colors?.backgroundDark || 'var(--gray-100)'};
    color: ${props => props.theme?.colors?.text || 'var(--gray-800)'};
    padding: 1em;
    border-radius: 4px;
    overflow-x: auto;
    margin: 0.5em 0 1em 0;
    font-size: 0.9em;
    line-height: 1.4;

    code {
      background-color: transparent;
      padding: 0;
      color: inherit;
      font-size: inherit;
      border-radius: 0;
    }
  }

  /* Links */
  a {
    color: ${props => props.$isUser 
      ? '#bbe1fa' 
      : (props.theme?.colors?.secondary || 'var(--primary)')
    };
    text-decoration: underline;
    
    &:hover {
      color: ${props => props.$isUser 
        ? '#d6edff' 
        : (props.theme?.colors?.secondaryLight || 'var(--primary-hover)')
      };
    }
  }

  /* Blockquotes - styled as theatrical asides */
  blockquote {
    border-left: 3px solid ${props => props.$isUser 
      ? 'rgba(255, 255, 255, 0.5)' 
      : (props.theme?.colors?.secondary || 'var(--gray-300)')
    };
    padding-left: 1em;
    margin-left: 0;
    margin-bottom: 0.8em;
    color: inherit;
    opacity: 0.9;
    font-style: italic;
    
    &:before {
      content: '"';
      font-size: 1.2em;
      margin-right: 0.2em;
    }
    
    &:after {
      content: '"';
      font-size: 1.2em;
      margin-left: 0.2em;
    }
  }

  /* Tables */
  table {
    border-collapse: collapse;
    margin-bottom: 1em;
    width: 100%;
    font-size: 0.9em;
    border: 1px solid ${props => props.theme?.colors?.border || 'var(--gray-300)'};
  }
  
  th, td {
    border: 1px solid ${props => props.theme?.colors?.border || 'var(--gray-300)'};
    padding: 0.5em 0.7em;
    text-align: left;
  }
  
  th {
    background-color: ${props => props.theme?.colors?.backgroundDark || 'var(--gray-100)'};
    font-weight: 600;
  }

  /* Horizontal Rules - styled as decorative dividers */
  hr {
    border: none;
    border-top: 1px solid ${props => props.$isUser 
      ? 'rgba(255, 255, 255, 0.3)' 
      : (props.theme?.colors?.border || 'var(--gray-300)')
    };
    margin: 1em 0;
    position: relative;
    
    &:after {
      content: '❦';
      position: absolute;
      top: -0.7em;
      left: 50%;
      transform: translateX(-50%);
      background: ${props => props.$isUser 
        ? props.theme?.colors?.primary || 'var(--primary)'
        : props.theme?.colors?.backgroundDark || 'var(--gray-200)'
      };
      padding: 0 0.5em;
      color: ${props => props.$isUser 
        ? 'rgba(255, 255, 255, 0.7)' 
        : (props.theme?.colors?.gold || 'var(--gray-800)')
      };
      font-size: 0.8em;
    }
  }
`;

// Form container at the bottom for input
export const InputForm = styled.form`
  border-top: 1px solid ${props => props.theme?.colors?.border || 'var(--gray-300)'};
  padding: 16px;
  background-color: ${props => props.theme?.colors?.backgroundDark || 'var(--background)'};
`;

// Flex container for the text input and send button
export const InputContainer = styled.div`
  display: flex;
  gap: 8px;
`;

// Text input field styling
export const TextInput = styled.input`
  flex: 1;
  padding: 8px 16px;
  border: 1px solid ${props => props.theme?.colors?.border || 'var(--gray-300)'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  font-size: 1rem;
  outline: none;
  background-color: ${props => props.theme?.colors?.background || 'var(--background)'};
  color: ${props => props.theme?.colors?.text || 'var(--foreground)'};
  font-family: ${props => props.theme?.fonts?.body || 'inherit'};

  &:focus {
    border-color: ${props => props.theme?.colors?.secondary || 'var(--primary)'};
    box-shadow: 0 0 0 2px rgba(71, 48, 128, 0.2);
  }

  &:disabled {
    background-color: ${props => props.theme?.colors?.backgroundDark || 'var(--gray-100)'};
    cursor: not-allowed;
    opacity: 0.7;
  }
  
  &::placeholder {
    color: ${props => props.theme?.colors?.textLight || 'var(--gray-800)'};
    font-style: italic;
  }
`;

// Send button styling
export const SendButton = styled.button`
  background-color: ${props => props.theme?.colors?.primary || 'var(--primary)'};
  color: white;
  border: none;
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  padding: 8px 16px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};

  &:hover:not(:disabled) {
    background-color: ${props => props.theme?.colors?.primaryLight || 'var(--primary-hover)'};
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  /* Add quill icon */
  &:before {
    content: '✒️';
    margin-right: 0.5rem;
  }
`;

// Loading indicator styling with a quill animation
export const LoadingIndicator = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 8px 0;
  color: ${props => props.theme?.colors?.textLight || 'var(--gray-800)'};
  font-style: italic;
  font-size: 0.9em;
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  
  &:before {
    content: "The Oracle ponders";
    margin-right: 0.5rem;
  }

  /* Quill pen animation */
  &:after {
    content: "✒️";
    display: inline-block;
    animation: quillWrite 1.8s infinite;
    transform-origin: bottom;
  }

  @keyframes quillWrite {
    0% { transform: rotate(-5deg); }
    25% { transform: rotate(10deg); }
    50% { transform: rotate(-5deg); }
    75% { transform: rotate(10deg); }
    100% { transform: rotate(-5deg); }
  }
`;

// Additional decorative components
export const Flourish = styled.div`
  text-align: center;
  margin: 1rem 0;
  font-size: 1.5rem;
  color: ${props => props.theme?.colors?.gold || '#c4a747'};
`;

export const PageContainer = styled.main`
  display: flex;
  min-height: 100vh;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  background-color: ${props => props.theme?.colors?.background || 'var(--background)'};
`;

export const ContentContainer = styled.div`
  width: 100%;
  max-width: 800px;
`;

export const PageTitle = styled.h1`
  font-size: 2.5rem;
  font-weight: bold;
  text-align: center;
  margin-bottom: 16px;
  color: ${props => props.theme?.colors?.primary || 'var(--foreground)'};
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  
  &:before, &:after {
    content: '✧';
    font-size: 2rem;
    margin: 0 1rem;
    color: ${props => props.theme?.colors?.gold || '#c4a747'};
    vertical-align: middle;
  }
`;

export const PageSubtitle = styled.h2`
  font-size: 1.25rem;
  text-align: center;
  margin-bottom: 32px;
  color: ${props => props.theme?.colors?.textLight || 'var(--gray-800)'};
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  font-style: italic;
  
  &:before, &:after {
    content: '~';
    margin: 0 0.5rem;
    color: ${props => props.theme?.colors?.secondary || 'var(--primary)'};
  }
`;// app/styles/theme.ts
import { DefaultTheme } from 'styled-components';

const theme: DefaultTheme = {
  colors: {
    // Primary colors
    primary: '#3a1e1c', // Deep, dark red (blood motif)
    primaryLight: '#6d3935', // Lighter version of primary
    primaryDark: '#2a1615', // Darker version of primary
    
    // Secondary colors
    secondary: '#473080', // Royal purple
    secondaryLight: '#6a52a2', // Lighter purple
    secondaryDark: '#2b1d4e', // Darker purple
    
    // Background colors
    background: '#f8f4e9', // Parchment color
    backgroundDark: '#e8dfc2', // Darker parchment
    
    // Text colors
    text: '#2d2416', // Dark brown text
    textLight: '#59463a', // Lighter text
    
    // Accent colors
    gold: '#c4a747', // Muted gold (crown/royalty)
    forest: '#2a4c34', // Forest green (Scottish highlands)
    fog: '#ced8dc', // Misty gray (Scottish moors)
    
    // Utility colors
    error: '#911f1c', // Error red
    success: '#2a4c34', // Success green
    border: '#59321f', // Border brown
  },
  
  fonts: {
    heading: "'EB Garamond', 'Libre Baskerville', serif",
    body: "'Cormorant', 'Times New Roman', serif",
    mono: "'Courier New', monospace",
  },
  
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
    xxl: '48px',
  },
  
  borderRadius: {
    small: '4px',
    medium: '8px',
    large: '12px',
    round: '50%',
  },
  
  shadows: {
    small: '0 2px 4px rgba(0, 0, 0, 0.1)',
    medium: '0 4px 8px rgba(0, 0, 0, 0.2)',
    large: '0 8px 16px rgba(0, 0, 0, 0.3)',
  },
};

export default theme;'use client';

import React, { useState, useRef, FormEvent, ChangeEvent } from 'react';
import styled from 'styled-components';

// --- Styled Components (with theme) ---
const UploaderContainer = styled.div`
  margin-top: 24px;
  padding: 20px;
  border: 1px solid ${props => props.theme?.colors?.border || '#59321f'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  background-color: ${props => props.theme?.colors?.backgroundDark || '#e8dfc2'};
  box-shadow: ${props => props.theme?.shadows?.medium || '0 4px 8px rgba(0, 0, 0, 0.2)'};
`;

const UploaderTitle = styled.h3`
  margin-bottom: 16px;
  color: ${props => props.theme?.colors?.primary || '#3a1e1c'};
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  font-size: 1.3rem;
`;

const UploadForm = styled.form`
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const FileInputContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const FileInputLabel = styled.label`
  padding: 12px;
  background-color: ${props => props.theme?.colors?.background || '#f8f4e9'};
  border: 1px dashed ${props => props.theme?.colors?.border || '#59321f'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
  font-family: ${props => props.theme?.fonts?.body || 'inherit'};
  color: ${props => props.theme?.colors?.text || '#2d2416'};
  
  &:hover {
    background-color: ${props => props.theme?.colors?.gold || '#c4a747'};
    color: ${props => props.theme?.colors?.primaryDark || '#2a1615'};
    border-color: ${props => props.theme?.colors?.primary || '#3a1e1c'};
  }
`;

const HiddenFileInput = styled.input`
  display: none;
`;

const MetadataContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const InputLabel = styled.label`
  font-size: 14px;
  font-weight: 500;
  color: ${props => props.theme?.colors?.primary || '#3a1e1c'};
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
`;

const TextInput = styled.input`
  padding: 8px 12px;
  border: 1px solid ${props => props.theme?.colors?.border || '#59321f'};
  border-radius: ${props => props.theme?.borderRadius?.small || '4px'};
  font-size: 14px;
  background-color: ${props => props.theme?.colors?.background || '#f8f4e9'};
  color: ${props => props.theme?.colors?.text || '#2d2416'};
  font-family: ${props => props.theme?.fonts?.body || 'inherit'};
  
  &:focus {
    border-color: ${props => props.theme?.colors?.secondary || '#473080'};
    outline: none;
    box-shadow: 0 0 0 2px rgba(71, 48, 128, 0.2);
  }
  
  &::placeholder {
    color: ${props => props.theme?.colors?.textLight || '#59463a'};
    font-style: italic;
  }
`;

const UploadButton = styled.button`
  background-color: ${props => props.theme?.colors?.secondary || '#473080'};
  color: white;
  border: 1px solid ${props => props.theme?.colors?.secondaryDark || '#2b1d4e'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 500;
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: ${props => props.theme?.shadows?.small || '0 2px 4px rgba(0, 0, 0, 0.1)'};
  
  &:before {
    content: '📜';
    margin-right: 0.5rem;
  }
  
  &:hover:not(:disabled) {
    background-color: ${props => props.theme?.colors?.secondaryLight || '#6a52a2'};
    transform: translateY(-2px);
    box-shadow: ${props => props.theme?.shadows?.medium || '0 4px 8px rgba(0, 0, 0, 0.2)'};
  }
  
  &:active:not(:disabled) {
    transform: translateY(0);
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const StatusMessage = styled.p<{ $isError?: boolean }>`
  margin-top: 12px;
  padding: 8px 12px;
  background-color: ${props => props.$isError 
    ? 'rgba(145, 31, 28, 0.1)' // Light red background based on theme.colors.error
    : 'rgba(42, 76, 52, 0.1)'}; // Light green background based on theme.colors.success
  color: ${props => props.$isError 
    ? props.theme?.colors?.error || '#911f1c' 
    : props.theme?.colors?.success || '#2a4c34'};
  border-radius: ${props => props.theme?.borderRadius?.small || '4px'};
  border-left: 3px solid ${props => props.$isError 
    ? props.theme?.colors?.error || '#911f1c' 
    : props.theme?.colors?.success || '#2a4c34'};
  font-family: ${props => props.theme?.fonts?.body || 'inherit'};
  font-style: italic;
`;

// --- Component Logic ---
interface DocumentMetadataForm {
  title: string;
  source: string;
  type: string;
}

export default function DocumentUploader() {
  // State for the selected file
  const [file, setFile] = useState<File | null>(null);
  // State for the metadata input fields
  const [metadata, setMetadata] = useState<DocumentMetadataForm>({
    title: '',
    source: '',
    type: 'notes', // Default type
  });
  // State for displaying status messages (success/error)
  const [status, setStatus] = useState<{ message: string; isError: boolean } | null>(null);
  // State to manage the uploading process (disable button etc.)
  const [isUploading, setIsUploading] = useState(false);
  // Ref to access the hidden file input element (e.g., for resetting)
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Handler for when a file is selected
  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0] || null;
    console.log("[DocumentUploader] handleFileChange: Selected file:", selectedFile);
    setFile(selectedFile);
    setStatus(null);

    if (selectedFile && !metadata.title) {
      const fileNameWithoutExt = selectedFile.name.replace(/\.[^/.]+$/, "");
      console.log(`[DocumentUploader] Auto-populating title: ${fileNameWithoutExt}`);
      setMetadata(prev => ({
        ...prev,
        title: fileNameWithoutExt,
      }));
    }
  };

  // Handler for changes in metadata text inputs
  const handleMetadataChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setMetadata(prev => ({
      ...prev,
      [name]: value,
    }));
  };

  // Handler for form submission
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    console.log("[DocumentUploader] handleSubmit triggered.");

    if (!file) {
      console.log("[DocumentUploader] Validation failed: No file selected.");
      setStatus({ message: 'Please select a file to upload', isError: true });
      return;
    }
     if (!metadata.title.trim()) {
        console.log("[DocumentUploader] Validation failed: Document Title is required.");
        setStatus({ message: 'Document Title is required', isError: true });
        return;
    }

    setIsUploading(true);
    setStatus(null);

    try {
      const formData = new FormData();
      formData.append('file', file, file.name);
      formData.append('metadata', JSON.stringify(metadata));
      console.log("[DocumentUploader] FormData prepared. Keys:", Array.from(formData.keys()));

      console.log("[DocumentUploader] Sending request to /api/admin/upload-document");
      const response = await fetch('/api/admin/upload-document', {
        method: 'POST',
        body: formData,
      });
      console.log(`[DocumentUploader] Received response with status: ${response.status}`);

      const data = await response.json();

      if (response.ok) {
        console.log("[DocumentUploader] Upload successful:", data);
        setStatus({ message: data.message || 'Document uploaded successfully!', isError: false });
        setFile(null);
        setMetadata({ title: '', source: '', type: 'notes' });
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
      } else {
        console.error("[DocumentUploader] Upload failed:", data);
        setStatus({ message: data.error || data.details || 'Failed to upload document', isError: true });
      }
    } catch (error) {
      console.error('[DocumentUploader] Error submitting document:', error);
      setStatus({ message: 'An unexpected network or client-side error occurred', isError: true });
    } finally {
      setIsUploading(false);
    }
  };

  // --- Component Render ---
  return (
    <UploaderContainer>
      <UploaderTitle>Upload Documents (Admin)</UploaderTitle>
      <UploadForm onSubmit={handleSubmit}>
        <FileInputContainer>
          <FileInputLabel htmlFor="admin-document-upload">
            {file ? `Selected: ${file.name}` : 'Click to select document (.txt, .pdf, .docx, .md)'}
          </FileInputLabel>
          <HiddenFileInput
            id="admin-document-upload"
            type="file"
            accept=".txt,.md,.pdf,.docx,.doc" // Updated to accept PDF and Word docs
            onChange={handleFileChange}
            ref={fileInputRef}
            disabled={isUploading}
          />
        </FileInputContainer>

        <MetadataContainer>
          <InputLabel htmlFor="doc-title">Document Title</InputLabel>
          <TextInput
            id="doc-title"
            name="title"
            value={metadata.title}
            onChange={handleMetadataChange}
            placeholder="E.g., Macbeth Act 1 Analysis"
            required
            disabled={isUploading}
          />
        </MetadataContainer>

        <MetadataContainer>
          <InputLabel htmlFor="doc-source">Source (Optional)</InputLabel>
          <TextInput
            id="doc-source"
            name="source"
            value={metadata.source}
            onChange={handleMetadataChange}
            placeholder="E.g., Lecture Notes Week 5, Study Guide Chapter 3"
            disabled={isUploading}
          />
        </MetadataContainer>

        <UploadButton type="submit" disabled={isUploading || !file}>
          {isUploading ? 'Transcribing...' : 'Upload Document'}
        </UploadButton>

        {status && (
          <StatusMessage $isError={status.isError}>
            {status.message}
          </StatusMessage>
        )}
      </UploadForm>
    </UploaderContainer>
  );
}// app/components/FileUpload.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';

// --- Styled Components with Shakespearean theme ---
const UploadContainer = styled.div`
  margin-bottom: 24px;
`;

const UploadButton = styled.label`
  display: inline-block;
  background-color: ${props => props.theme?.colors?.backgroundDark || 'var(--gray-200)'};
  color: ${props => props.theme?.colors?.text || 'var(--gray-800)'};
  border: 1px solid ${props => props.theme?.colors?.border || 'var(--gray-300)'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  padding: 8px 16px;
  font-size: 14px;
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  cursor: pointer;
  transition: all 0.2s;
  
  /* Add a scroll icon */
  &:before {
    content: '📜';
    margin-right: 0.5rem;
  }
  
  &:hover {
    background-color: ${props => props.theme?.colors?.secondary || 'var(--gray-300)'};
    color: white;
  }
`;

const HiddenInput = styled.input`
  display: none;
`;

const FileList = styled.ul`
  list-style: none;
  margin-top: 12px;
  padding: 0;
`;

const FileItem = styled.li`
  display: flex;
  align-items: center;
  padding: 8px 12px;
  margin-bottom: 8px;
  background-color: ${props => props.theme?.colors?.backgroundDark || 'var(--gray-100)'};
  border: 1px solid ${props => props.theme?.colors?.border || 'var(--gray-300)'};
  border-radius: ${props => props.theme?.borderRadius?.small || '4px'};
  font-size: 14px;
  font-family: ${props => props.theme?.fonts?.body || 'inherit'};
`;

const FileName = styled.span`
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const FileStatus = styled.span<{ $isSuccess?: boolean; $isError?: boolean }>`
  margin-left: 8px;
  font-size: 12px;
  font-style: italic;
  color: ${props =>
    props.$isSuccess ? (props.theme?.colors?.success || 'green') :
    props.$isError ? (props.theme?.colors?.error || 'red') :
    (props.theme?.colors?.textLight || 'var(--gray-800)')};
`;
// --- End Styled Components ---


// --- Component Props ---
type FileUploadProps = {
  // Function passed from parent to handle the files once selected
  onFileUpload: (files: File[]) => Promise<void>;
};


// --- Component Definition ---
export default function FileUpload({ onFileUpload }: FileUploadProps) {
  // State to manage the list of files shown in the UI and their status
  const [uploadedFiles, setUploadedFiles] = useState<Array<{
    file: File;
    status: 'uploading' | 'success' | 'error';
  }>>([]);

  // --- File Input Change Handler - Keeping all logging as is ---
  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    console.log('[FileUpload.tsx] handleFileChange triggered.');

    if (!e.target.files || e.target.files.length === 0) {
      console.log('[FileUpload.tsx] No files selected in input event.');
      return;
    }

    console.log('[FileUpload.tsx] e.target.files (FileList):', e.target.files);
    const files = Array.from(e.target.files);
    console.log('[FileUpload.tsx] Files obtained from event target (Array):', files);
    if (files.length > 0) {
         files.forEach((f, i) => console.log(`[FileUpload.tsx] File ${i}: ${f.name}, Size: ${f.size}, Type: ${f.type}`));
    } else {
         console.log('[FileUpload.tsx] FileList conversion resulted in empty array.');
         return;
    }

    const newUploadingFiles = files.map(file => ({ file, status: 'uploading' as const }));
    setUploadedFiles(prev => [...prev, ...newUploadingFiles]);
    console.log('[FileUpload.tsx] Updated UI state to show newly selected files as uploading.');

    try {
      console.log('[FileUpload.tsx] Calling onFileUpload prop function with validated files array:', files);
      await onFileUpload(files);
      console.log('[FileUpload.tsx] onFileUpload prop function completed successfully.');

      setUploadedFiles(prev =>
        prev.map(item =>
             files.some(f => f.name === item.file.name && f.size === item.file.size) && item.status === 'uploading'
            ? { ...item, status: 'success' as const }
            : item
        )
      );
    } catch (error) {
      console.error('[FileUpload.tsx] Error caught after calling onFileUpload:', error);

      setUploadedFiles(prev =>
        prev.map(item =>
            files.some(f => f.name === item.file.name && f.size === item.file.size) && item.status === 'uploading'
            ? { ...item, status: 'error' as const }
            : item
        )
      );
    } finally {
        if (e.target) {
            e.target.value = '';
            console.log('[FileUpload.tsx] File input value reset.');
        }
    }
  };

  // --- Component Render ---
  return (
    <UploadContainer>
      {/* The label text is updated, but ID remains the same */}
      <UploadButton htmlFor="file-upload">
        Consult Ancient Texts (.txt, .pdf, .docx)
      </UploadButton>

      {/* Keep all properties the same */}
      <HiddenInput
        id="file-upload"
        type="file"
        multiple
        accept=".pdf,.txt,.docx,.doc,.md"
        onChange={handleFileChange}
      />

      {/* Update status text to be more Shakespearean */}
      {uploadedFiles.length > 0 && (
        <FileList>
          {uploadedFiles.map((item, index) => (
            <FileItem key={`${item.file.name}-${index}-${item.status}`}>
              <FileName title={item.file.name}>{item.file.name}</FileName>
              <FileStatus
                $isSuccess={item.status === 'success'}
                $isError={item.status === 'error'}
              >
                {item.status === 'uploading' && 'Transcribing...'}
                {item.status === 'success' && 'Inscribed'} 
                {item.status === 'error' && 'Misfortune!'}
              </FileStatus>
            </FileItem>
          ))}
        </FileList>
      )}
    </UploadContainer>
  );
}'use client';

import React, { useState } from 'react';
import styled from 'styled-components';

const AdminContainer = styled.div`
  margin-top: 40px;
  padding: 20px;
  border: 1px solid ${props => props.theme?.colors?.border || '#59321f'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  background-color: ${props => props.theme?.colors?.backgroundDark || '#e8dfc2'};
  box-shadow: ${props => props.theme?.shadows?.medium || '0 4px 8px rgba(0, 0, 0, 0.2)'};
  position: relative;
  
  /* Decorative corner curl */
  &:after {
    content: '';
    position: absolute;
    bottom: 0;
    right: 0;
    width: 20px;
    height: 20px;
    background: linear-gradient(135deg, transparent 50%, rgba(89, 50, 31, 0.2) 50%);
    border-radius: 0 0 ${props => props.theme?.borderRadius?.medium || '8px'} 0;
  }
`;

const AdminTitle = styled.h3`
  margin-bottom: 16px;
  color: ${props => props.theme?.colors?.primary || '#3a1e1c'};
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  font-size: 1.3rem;
  
  &:before, &:after {
    content: '❦';
    margin: 0 0.5rem;
    color: ${props => props.theme?.colors?.gold || '#c4a747'};
    font-size: 0.9rem;
    vertical-align: middle;
  }
`;

const AdminButton = styled.button`
  background-color: ${props => props.theme?.colors?.secondary || '#473080'};
  color: white;
  border: 1px solid ${props => props.theme?.colors?.secondaryDark || '#2b1d4e'};
  border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
  padding: 8px 16px;
  font-size: 0.9rem;
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: ${props => props.theme?.shadows?.small || '0 2px 4px rgba(0, 0, 0, 0.1)'};
  
  &:before {
    content: '✒️';
    margin-right: 0.5rem;
  }
  
  &:hover:not(:disabled) {
    background-color: ${props => props.theme?.colors?.secondaryLight || '#6a52a2'};
    transform: translateY(-2px);
    box-shadow: ${props => props.theme?.shadows?.medium || '0 4px 8px rgba(0, 0, 0, 0.2)'};
  }
  
  &:active:not(:disabled) {
    transform: translateY(0);
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const StatusMessage = styled.p<{ $isError?: boolean }>`
  margin-top: 16px;
  padding: 8px 12px;
  background-color: ${props => props.$isError 
    ? 'rgba(145, 31, 28, 0.1)' // Light red background based on theme.colors.error
    : 'rgba(42, 76, 52, 0.1)'}; // Light green background based on theme.colors.success
  color: ${props => props.$isError 
    ? props.theme?.colors?.error || '#911f1c' 
    : props.theme?.colors?.success || '#2a4c34'};
  border-radius: ${props => props.theme?.borderRadius?.small || '4px'};
  border-left: 3px solid ${props => props.$isError 
    ? props.theme?.colors?.error || '#911f1c' 
    : props.theme?.colors?.success || '#2a4c34'};
  font-family: ${props => props.theme?.fonts?.body || 'inherit'};
  font-style: italic;
`;

export default function AdminPanel() {
  const [isLoading, setIsLoading] = useState(false);
  const [status, setStatus] = useState<string | null>(null);
  const [isError, setIsError] = useState(false);
  
  const seedDatabase = async () => {
    if (isLoading) return;
    
    setIsLoading(true);
    setStatus('Seeding database with Macbeth content...');
    setIsError(false);
    
    try {
      // Get admin API key from environment or prompt user
      const adminApiKey = prompt('Enter admin API key:');
      
      if (!adminApiKey) {
        setStatus('Seeding cancelled');
        setIsLoading(false);
        return;
      }
      
      const response = await fetch('/api/seed', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${adminApiKey}`,
        },
      });
      
      const data = await response.json();
      
      if (response.ok) {
        setStatus(data.message || 'Successfully seeded database!');
        setIsError(false);
      } else {
        setStatus(`Error: ${data.error || 'Failed to seed database'}`);
        setIsError(true);
      }
    } catch (error) {
      console.error('Error seeding database:', error);
      setStatus('An unexpected error occurred while seeding the database.');
      setIsError(true);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <AdminContainer>
      <AdminTitle>Admin Panel</AdminTitle>
      <AdminButton 
        onClick={seedDatabase}
        disabled={isLoading}
      >
        {isLoading ? 'Seeding...' : 'Seed Pinecone Database'}
      </AdminButton>
      
      {status && (
        <StatusMessage $isError={isError}>
          {status}
        </StatusMessage>
      )}
    </AdminContainer>
  );
}// app/components/ThemeProvider.tsx
'use client';

import React from 'react';
import { createGlobalStyle, ThemeProvider as StyledThemeProvider } from 'styled-components';
import theme from '../styles/theme';

// Create global styles for the app
const GlobalStyle = createGlobalStyle`
  /* Import Google Fonts */
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Cormorant:wght@400;500;600&display=swap');
  
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }
  
  html, body {
    max-width: 100vw;
    height: 100%;
    overflow-x: hidden;
    background-color: ${({ theme }) => theme.colors.background};
    color: ${({ theme }) => theme.colors.text};
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.6;
  }
  
  h1, h2, h3, h4, h5, h6 {
    font-family: ${({ theme }) => theme.fonts.heading};
    font-weight: 600;
    line-height: 1.3;
    color: ${({ theme }) => theme.colors.primary};
  }
  
  a {
    color: ${({ theme }) => theme.colors.secondary};
    text-decoration: none;
    transition: color 0.2s ease;
    
    &:hover {
      color: ${({ theme }) => theme.colors.secondaryLight};
      text-decoration: underline;
    }
  }
  
  button {
    font-family: ${({ theme }) => theme.fonts.heading};
    cursor: pointer;
  }
`;

export default function ThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <StyledThemeProvider theme={theme}>
      <GlobalStyle />
      {children}
    </StyledThemeProvider>
  );
}// app/components/Chat.tsx
'use client';

import { useState, FormEvent, useEffect } from 'react'; // Added useEffect
import { nanoid } from 'nanoid';
import ChatInput from './ChatInput';
import ChatMessage from './ChatMessage';
import FileUpload from './FileUpload'; // Use this for user uploads
import {
  ChatContainer,
  MessagesList,
  LoadingIndicator
} from '@/app/styles/ChatStyles';
import { Message } from '@/app/types';

export default function Chat() {
  const [messages, setMessages] = useState<Message[]>([
    {
      id: 'system-1',
      role: 'system',
      // Update to more theatrical language
      content: "Thou art speaking with the MacBeth Oracle, a learned scholar of the Scottish Play. This Oracle shall illuminate themes, characters, tragic arcs, and the bard's devices within Shakespeare's darkest tragedy. The Oracle draws wisdom from scrolls thou uploadeth using the 'Consult Ancient Texts' button. Responses shall be scholarly yet engaging, with references to acts and scenes when fitting. If no knowledge exists within the Oracle's scrolls, it shall declare such ignorance rather than weave falsehoods."
    }
  ]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false); // For chat response loading
  // State to track if *any* files have been successfully uploaded in this session
  const [hasUploadedFiles, setHasUploadedFiles] = useState(false);
  // State for displaying upload status feedback
  const [uploadStatus, setUploadStatus] = useState<{ error: boolean; message: string | null }>({ error: false, message: null });

  // Effect to automatically clear status messages after a delay
  useEffect(() => {
    if (uploadStatus.message) {
        const timer = setTimeout(() => {
            setUploadStatus({ error: false, message: null });
        }, 5000); // Clear message after 5 seconds
        return () => clearTimeout(timer);
    }
  }, [uploadStatus]);


  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setInput(e.target.value);
  };

  // Handles files selected via the FileUpload component
  const handleFileUpload = async (files: File[]) => {
    console.log('[Chat.tsx] handleFileUpload received files:', files);
    setUploadStatus({ error: false, message: 'Uploading...' }); // Show uploading status

    if (!files || files.length === 0) {
        console.error('[Chat.tsx] handleFileUpload received no files!');
        setUploadStatus({ error: true, message: 'No files were selected.' });
        return;
    }

    // Prepare form data for the /api/upload route
    const formData = new FormData();
    const serverExpectedFileKey = 'files'; // Key expected by /api/upload
    let fileAppendError = false;

    files.forEach((file, index) => {
      if (file instanceof File) {
          formData.append(serverExpectedFileKey, file, file.name);
          console.log(`[Chat.tsx] Appended file ${index}: ${file.name} to formData with key '${serverExpectedFileKey}'`);
      } else {
          console.error(`[Chat.tsx] Item at index ${index} is not a valid File object:`, file);
          setUploadStatus({ error: true, message: `Invalid item detected during upload.` });
          fileAppendError = true; // Set flag
      }
    });

    // Stop if there was an issue appending files
    if (fileAppendError) return;

    // Verify formData content before sending (for debugging)
    const formDataKeys = Array.from(formData.keys());
    console.log('[Chat.tsx] FormData keys before sending:', formDataKeys);
    const filesInFormData = formData.getAll(serverExpectedFileKey);
    console.log(`[Chat.tsx] Final check: formData.getAll('${serverExpectedFileKey}') found ${filesInFormData.length} entries.`);
    if (filesInFormData.length !== files.length) {
        console.error(`[Chat.tsx] Mismatch! Files appended (${files.length}) vs files in FormData (${filesInFormData.length}). Upload aborted.`);
        setUploadStatus({ error: true, message: `Internal error preparing upload data. Please try again.` });
        return;
    }

    console.log('[Chat.tsx] Sending fetch request to /api/upload...');
    try {
        // Send files to the dedicated upload endpoint
        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData,
        });
        console.log(`[Chat.tsx] Received response from /api/upload with status: ${response.status}`);

        // Handle response from the upload API
        if (!response.ok) {
            let errorDetails = `Server returned status ${response.status}`;
            try {
                 const errorData = await response.json();
                 errorDetails = errorData.error || errorData.details || errorData.message || JSON.stringify(errorData);
            } catch {
                 try { errorDetails = await response.text(); } catch {} // Fallback to text
            }
            console.error(`[Chat.tsx] File upload fetch failed! Status: ${response.status}, Details: ${errorDetails}`);
            setUploadStatus({ error: true, message: `Upload failed: ${errorDetails}` });
            // Propagate error to FileUpload component's catch block if needed
            throw new Error(`File upload failed: ${errorDetails}`);
        }

        // Success Handling
        setHasUploadedFiles(true); // Set the flag indicating files are now available for RAG
        const responseData = await response.json();
        console.log('[Chat.tsx] File upload successful:', responseData);
        setUploadStatus({ error: false, message: responseData.message || 'Upload successful!' });

        // Get names of processed files from response for the confirmation message
        const processedFileNames = responseData.processedFiles?.map((f: { name: string }) => f.name) || [];
        const confirmationMessage = processedFileNames.length > 0
            ? `Processed: ${processedFileNames.join(', ')}. You can now ask questions about the content!`
            : "File processed. Ask questions about the content!"; // Fallback message

        // Add assistant message confirming the upload
        setMessages(prev => [
          ...prev,
          { id: nanoid(), role: 'assistant', content: confirmationMessage }
        ]);

    } catch (error) {
        // Catch network errors or errors thrown from !response.ok
        console.error('[Chat.tsx] Error during file upload fetch/processing:', error);
        if (!uploadStatus.error) { // Avoid overwriting specific error from !response.ok
             setUploadStatus({ error: true, message: error instanceof Error ? error.message : 'Upload network error.' });
        }
        // Error is caught here, no need to throw again unless FileUpload depends on it
    }
  };


  // Handles sending chat messages to the /api/chat route
  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const trimmedInput = input.trim();
    if (!trimmedInput || isLoading) return;

    // Create the user message object
    const userMessage: Message = {
      id: nanoid(),
      role: 'user',
      content: trimmedInput,
      createdAt: new Date()
    };

    // Add user message to state immediately
    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true); // Set loading state for AI response
    setInput(''); // Clear input field

    try {
      // Prepare request body for chat API
      // No filterFileName needed anymore
      const requestBody = {
          messages: [...messages, userMessage], // Send message history + new message
          useUploadedFiles: hasUploadedFiles, // Send flag to trigger RAG on server
      };
      console.log('[Chat.tsx] Sending chat request with body:', requestBody);

      // Call the chat API endpoint
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });

      // Handle chat API response
      if (!response.ok) {
        let errorDetails = `Chat API error! Status: ${response.status}`;
        try {
            const errorData = await response.json();
            errorDetails = errorData.error || errorData.details || JSON.stringify(errorData);
        } catch {
            try { errorDetails = await response.text() || errorDetails; } catch {}
        }
         console.error(`[Chat.tsx] Chat API fetch error: ${errorDetails}`);
        throw new Error(errorDetails); // Throw to be caught below
      }

      // Process the streamed response
      if (response.body) {
        const responseId = nanoid();
        // Add empty assistant message placeholder
        setMessages(prev => [
          ...prev,
          { id: responseId, role: 'assistant', content: '' }
        ]);

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let responseText = '';

        // Stream content into the placeholder message
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          responseText += chunk;

          setMessages(prev => {
            const newMessages = [...prev];
            const lastMessageIndex = newMessages.findLastIndex(m => m.id === responseId);
            if (lastMessageIndex !== -1) {
                newMessages[lastMessageIndex] = { ...newMessages[lastMessageIndex], content: responseText };
            } else { /* Should not happen */ }
            return newMessages;
          });
        }
      } else {
          console.warn("[Chat.tsx] Chat API response was ok but had no body.");
          // Maybe add a default "empty response" message?
          setMessages(prev => [...prev, { id: nanoid(), role: 'assistant', content: "[Received empty response]" }]);
      }
      setIsLoading(false); // Clear loading state after streaming finishes

    } catch (error) {
      // Handle errors during chat API call or streaming
      console.error('[Chat.tsx] Error sending chat message or processing response:', error);
      setIsLoading(false); // Clear loading state on error
      // Add error message to the chat
      setMessages(prev => [
        ...prev,
        {
          id: nanoid(),
          role: 'assistant',
          content: `Sorry, could not get a response. Error: ${error instanceof Error ? error.message : 'Unknown issue'}`,
        }
      ]);
    }
  }; // --- End handleSubmit ---


  // --- Component Render ---
  return (
    <ChatContainer>
      {/* FileUpload component triggers handleFileUpload */}
      <FileUpload onFileUpload={handleFileUpload} />

      {/* Display upload status message */}
       {uploadStatus.message && (
         <p style={{ padding: '8px 16px', color: uploadStatus.error ? 'red' : 'green', fontSize: '0.9em', textAlign: 'center' }}>
           {uploadStatus.message}
         </p>
       )}

      {/* Messages list */}
      <MessagesList>
        {messages.map(message =>
          message.role !== 'system' && ( // Don't render system messages
            <ChatMessage key={message.id} message={message} />
          )
        )}
        {/* Show loading indicator only when waiting for chat response */}
        {isLoading && <LoadingIndicator>Macbot is thinking</LoadingIndicator>}
      </MessagesList>

      {/* Chat input form */}
      <ChatInput
        value={input}
        onChange={handleInputChange}
        onSubmit={handleSubmit}
        isLoading={isLoading} // Disable input while AI is responding
      />
    </ChatContainer>
  );
} // --- End Chat Component ---// app/components/ChatMessage.tsx
'use client';

import { Message } from '@/app/types';
import { MessageBubble } from '@/app/styles/ChatStyles';
import ReactMarkdown from 'react-markdown'; // Import ReactMarkdown
import remarkGfm from 'remark-gfm'; // Import remark-gfm for extended syntax (tables, etc.)

type ChatMessageProps = {
  message: Message;
};

export default function ChatMessage({ message }: ChatMessageProps) {
  const isUser = message.role === 'user';

  return (
    <MessageBubble $isUser={isUser}>
      {/*
        Conditionally render using ReactMarkdown only for 'assistant' messages.
        User messages are treated as plain text.
        Pass remarkGfm plugin for GitHub Flavored Markdown support.
      */}
      {isUser ? (
        message.content // Render user messages as plain text
      ) : (
        <ReactMarkdown remarkPlugins={[remarkGfm]}>
          {message.content}
        </ReactMarkdown>
      )}
    </MessageBubble>
  );
}// app/components/ChatInput.tsx
'use client';

import { FormEvent } from 'react';
import { 
  InputForm, 
  InputContainer, 
  TextInput, 
  SendButton 
} from '@/app/styles/ChatStyles';
import styled from 'styled-components';

// Add decoration to the send button
const StylizedSendButton = styled(SendButton)`
  display: flex;
  align-items: center;
  justify-content: center;
  
  &:before {
    content: '✒️';
    margin-right: 0.5rem;
  }
`;

type ChatInputProps = {
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onSubmit: (e: FormEvent<HTMLFormElement>) => void;
  isLoading: boolean;
};

export default function ChatInput({ 
  value, 
  onChange, 
  onSubmit, 
  isLoading 
}: ChatInputProps) {
  return (
    <InputForm onSubmit={onSubmit}>
      <InputContainer>
        <TextInput
          type="text"
          value={value}
          onChange={onChange}
          placeholder="Pose thy query about Macbeth..."
          disabled={isLoading}
        />
        <StylizedSendButton 
          type="submit" 
          disabled={isLoading || !value.trim()}
        >
          Dispatch
        </StylizedSendButton>
      </InputContainer>
    </InputForm>
  );
}// app/layout.tsx - Updated with proper styled-components setup
import { Inter } from 'next/font/google';
import type { Metadata } from 'next';
import './globals.css';
import StyledComponentsRegistry from './lib/registry';
import ThemeProvider from './components/ThemeProvider';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Macbot - Your Macbeth Study Assistant',
  description: 'AI-powered chatbot to help students study Shakespeare\'s Macbeth',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <StyledComponentsRegistry>
          <ThemeProvider>{children}</ThemeProvider>
        </StyledComponentsRegistry>
      </body>
    </html>
  );
}import Together from "together-ai";

// Check if the API key is defined
const apiKey = process.env.TOGETHER_API_KEY;

if (!apiKey) {
  console.error("Missing TOGETHER_API_KEY environment variable");
}

// Initialize the Together client
const togetherClient = new Together({
  apiKey: apiKey || "",
});

export const modelName = "meta-llama/Llama-3.3-70B-Instruct-Turbo-Free";

export default togetherClient;// app/lib/pinecone-client.ts
import {
  Pinecone,
  PineconeRecord,
  // Consider importing specific error types if available in your SDK version
  // (e.g., PineconeNotFoundError, PineconeConflictError) for more reliable checks.
} from '@pinecone-database/pinecone';
import { VectorSearchResult } from '@/app/types'; // Your application's search result type

// --- Environment Variables ---
const pineconeApiKey = process.env.PINECONE_API_KEY;
const pineconeIndexName = process.env.PINECONE_INDEX; // Ensure this matches .env.local

// Basic check for environment variables
if (!pineconeApiKey) {
  console.error('ERROR: Missing Pinecone API key. Please set PINECONE_API_KEY environment variable.');
  // Consider throwing error in production
}
if (!pineconeIndexName) {
  console.error('ERROR: Missing Pinecone index name. Please set PINECONE_INDEX environment variable.');
  // Consider throwing error in production
}

// --- Metadata Type Definition for Pinecone Storage ---
// This defines how metadata should be structured when STORED in Pinecone.
export type PineconeDocumentMetadata = {
  fileName: string;
  pageNumber?: string; // Store as string | undefined
  chunkIndex: string; // Store as string
  content: string;
  uploadedAt?: string; // Optional: Timestamp as ISO string
};

// --- Initialize Pinecone Client ---
const pinecone = new Pinecone({
  apiKey: pineconeApiKey || 'MISSING_API_KEY', // Fallback or ensure checks throw
});

// --- Get or Create Index Function ---
export const getIndex = async () => {
  if (!pineconeIndexName) {
    throw new Error("Pinecone index name is not configured.");
  }
  console.log(`Attempting to get or create Pinecone index: ${pineconeIndexName}`);
  try {
    // 1. Try describeIndex first
    await pinecone.describeIndex(pineconeIndexName);
    console.log(`Index '${pineconeIndexName}' found.`);
    return pinecone.index<PineconeDocumentMetadata>(pineconeIndexName);
  } catch (error: unknown) {
    // 2. Check if it's a "Not Found" error
    let isNotFoundError = false;
    if (typeof error === 'object' && error !== null) {
      if ('status' in error && (error as { status: number }).status === 404) {
          isNotFoundError = true;
          console.log(`describeIndex error identified as 404 Not Found via status code.`);
      } else if ('name' in error && (error as { name: string }).name === 'PineconeNotFoundError') {
          isNotFoundError = true;
          console.log(`describeIndex error identified as PineconeNotFoundError via name.`);
      }
    }
    if (!isNotFoundError && error instanceof Error) {
        const errorMsgLower = error.message.toLowerCase();
        if (errorMsgLower.includes('not found') && (errorMsgLower.includes('index') || errorMsgLower.includes(pineconeIndexName.toLowerCase()))) {
            isNotFoundError = true;
            console.log(`describeIndex error identified as 'not found' via message content.`);
        }
    }
    if (!isNotFoundError && !(error instanceof Error && (error.message.includes('404') || error.message.includes('not found')))) {
         console.log("describeIndex failed with an error that doesn't appear to be a 'Not Found' error:", error);
    }

    // 3. If not found, create it
    if (isNotFoundError) {
      console.log(`Index '${pineconeIndexName}' not found. Attempting creation...`);
      try {
        await pinecone.createIndex({
          name: pineconeIndexName,
          // === UPDATED DIMENSION BACK TO 768 ===
          dimension: 768, // Set to match OpenAI text-embedding-3-small dimension parameter
          // ====================================
          metric: 'cosine',
          spec: { serverless: { cloud: 'aws', region: 'us-east-1' } },
        });
        console.log(`Index '${pineconeIndexName}' creation initiated with dimension 768. Waiting ~60s...`);
        await new Promise(resolve => setTimeout(resolve, 60000));
        console.log(`Index '${pineconeIndexName}' assumed ready.`);
        return pinecone.index<PineconeDocumentMetadata>(pineconeIndexName);
      } catch (creationError: unknown) {
        // 4. Handle creation errors (like 409 Conflict)
        console.error(`Failed to create index '${pineconeIndexName}':`, creationError);
        let isConflictError = false;
         if (creationError instanceof Error) {
             isConflictError = creationError.message.includes('409') || creationError.message.includes('ALREADY_EXISTS');
         } else if (typeof creationError === 'object' && creationError !== null && 'status' in creationError && (creationError as { status: number }).status === 409) {
             isConflictError = true;
         }
         if (isConflictError) {
             console.warn(`Index creation 409 Conflict. Assuming index exists.`);
             return pinecone.index<PineconeDocumentMetadata>(pineconeIndexName);
         }
        throw creationError;
      }
    } else {
      // 5. Re-throw unexpected describeIndex errors
      console.error(`Unexpected error describing index '${pineconeIndexName}':`, error);
      throw error;
    }
  }
};


// --- Insert Vectors Function ---
// Expects vectors with metadata matching PineconeDocumentMetadata
export const insertVectors = async (
  vectors: PineconeRecord<PineconeDocumentMetadata>[]
) => {
  if (!pineconeIndexName) throw new Error("Pinecone index name is not configured.");
  if (!vectors || vectors.length === 0) {
    console.warn("insertVectors called with no vectors.");
    return true;
  }
  try {
    const index = await getIndex();
    console.log(`Inserting ${vectors.length} vectors into index '${pineconeIndexName}'`);
    const batchSize = 100;
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(vectors.length / batchSize)} (size: ${batch.length})`);
      await index.upsert(batch);
    }
    console.log(`Successfully inserted ${vectors.length} vectors.`);
    return true;
  } catch (error) {
    console.error('Error inserting vectors:', error);
    throw error;
  }
};


// --- Query Vectors Function ---
// Fetches similar chunks and formats the result
export const querySimilarChunks = async (
  queryEmbedding: number[],
  topK: number = 5
): Promise<VectorSearchResult[]> => {
  if (!pineconeIndexName) throw new Error("Pinecone index name is not configured.");
  if (!queryEmbedding || queryEmbedding.length === 0) { console.error("Empty query embedding."); return []; }

  // === UPDATED DIMENSION CHECK BACK TO 768 ===
  if (queryEmbedding.length !== 768) {
       console.error(`Query embedding dimension mismatch. Expected 768, got ${queryEmbedding.length}.`);
       return [];
  }
  // =========================================

  try {
    const index = await getIndex();
    console.log(`Querying index '${pineconeIndexName}' with topK=${topK}.`);

    const queryOptions: Parameters<typeof index.query>[0] = {
        vector: queryEmbedding,
        topK,
        includeMetadata: true,
    };

    const queryResponse = await index.query(queryOptions);
    console.log(`Query returned ${queryResponse.matches?.length ?? 0} matches.`);

    // Map results
    const results: VectorSearchResult[] = [];
    if (queryResponse.matches) {
        for (const match of queryResponse.matches) {
            const metadata = match.metadata as PineconeDocumentMetadata | undefined;
            if (!metadata || typeof metadata.content !== 'string' || typeof metadata.fileName !== 'string' || typeof metadata.chunkIndex !== 'string') { continue; }
            const pageNumStr = metadata.pageNumber;
            const chunkIdxStr = metadata.chunkIndex;
            const chunkIndex = parseInt(chunkIdxStr, 10);
            if (isNaN(chunkIndex)) { continue; }
            let pageNumber: number | undefined = undefined;
            if (typeof pageNumStr === 'string') {
                 const parsedPage = parseInt(pageNumStr, 10);
                 if (!isNaN(parsedPage)) pageNumber = parsedPage;
                 else console.warn(`Match ${match.id}: Could not parse pageNumber '${pageNumStr}'.`);
            }
            results.push({
                id: match.id,
                score: match.score ?? 0,
                content: metadata.content,
                metadata: {
                    fileName: metadata.fileName,
                    pageNumber: pageNumber,
                    chunkIndex: chunkIndex,
                },
            });
        }
    }
    return results;

  } catch (error) {
    console.error('Error querying vectors:', error);
    throw error;
  }
};


// --- Export Client Object ---
const pineconeClient = {
  insertVectors,
  querySimilarChunks,
  getIndex,
};

export default pineconeClient;// app/lib/embedding-utils.ts
import OpenAI from 'openai'; // Import OpenAI SDK

// Initialize OpenAI Client (uses OPENAI_API_KEY from environment)
const openai = new OpenAI();

// Define OpenAI model details
const OPENAI_EMBEDDING_MODEL = "text-embedding-3-small";
const EXPECTED_DIMENSION = 768; // ** Crucial: Requesting this dimension **

/**
 * Generate single embedding for a text string using OpenAI
 */
export async function generateEmbedding(text: string): Promise<number[]> {
  if (!text || typeof text !== 'string' || text.trim().length === 0) {
    console.warn("[OpenAI Embed] Attempted to embed empty or invalid text.");
    return Array(EXPECTED_DIMENSION).fill(0); // Return zero vector
  }

  const cleanedText = text.replace(/\n/g, " ").trim();
  if (!cleanedText) {
    console.warn("[OpenAI Embed] Text became empty after cleaning.");
    return Array(EXPECTED_DIMENSION).fill(0);
  }

  console.log(`[OpenAI Embed] Generating embedding for query text (length: ${cleanedText.length}) using ${OPENAI_EMBEDDING_MODEL} (dim: ${EXPECTED_DIMENSION})...`);

  try {
    const response = await openai.embeddings.create({
      model: OPENAI_EMBEDDING_MODEL,
      input: [cleanedText], // API expects an array of strings
      // ** Request specific dimension **
      dimensions: EXPECTED_DIMENSION,
      encoding_format: "float", // Recommended format
    });

    // Validate response structure and extract embedding
    const embedding = response?.data?.[0]?.embedding;
    if (!embedding || !Array.isArray(embedding)) {
      console.error("[OpenAI Embed] Unexpected response structure:", response);
      throw new Error(`Unexpected response structure from OpenAI API for ${OPENAI_EMBEDDING_MODEL}.`);
    }

    // Optional: Double-check dimension, though requesting it should ensure it
    if (embedding.length !== EXPECTED_DIMENSION) {
        console.warn(`[OpenAI Embed] Warning: Embedding dimension mismatch. Requested ${EXPECTED_DIMENSION}, got ${embedding.length}.`);
        // Handle this case if necessary (e.g., throw error)
    }

    console.log(`[OpenAI Embed] Embedding generated successfully (${embedding.length}d).`);
    return embedding;

  } catch (error) {
    console.error(`[OpenAI Embed] Error generating embedding with ${OPENAI_EMBEDDING_MODEL}:`, error);
    throw error; // Re-throw for upstream handling
  }
}

// --- REMOVED Seeding and other utility functions if no longer needed ---
// Keep formatRetrievedContext if used by chat route, ensure it accepts VectorSearchResult[]
/*
import { VectorSearchResult } from "@/app/types";

export function formatRetrievedContext(docs: VectorSearchResult[]): string {
    // ... implementation using VectorSearchResult ...
}
*/// app/lib/embeddings.ts
import OpenAI from 'openai'; // Import OpenAI SDK
import { FileChunk } from '@/app/types';
import { PineconeRecord } from '@pinecone-database/pinecone';
import { PineconeDocumentMetadata } from './pinecone-client'; // Import metadata type

// Initialize OpenAI Client (uses OPENAI_API_KEY from environment)
const openai = new OpenAI();

// --- OpenAI Configuration ---
// ** Ensure these match the settings in embedding-utils.ts and pinecone-client.ts **
const OPENAI_EMBEDDING_MODEL = "text-embedding-3-small";
const EXPECTED_DIMENSION = 768; // Requesting 768 dimensions
// --- End OpenAI Configuration ---

/**
 * Generate embeddings for multiple FileChunks using OpenAI API - CORRECTED
 */
export async function generateEmbeddings(
  chunks: FileChunk[]
): Promise<PineconeRecord<PineconeDocumentMetadata>[]> {
  // Handle empty input
  if (!chunks || chunks.length === 0) {
    console.log("generateEmbeddings (OpenAI) called with empty chunks array.");
    return [];
  }
  console.log(`[OpenAI Embed] Generating embeddings for ${chunks.length} chunks using ${OPENAI_EMBEDDING_MODEL} (dim: ${EXPECTED_DIMENSION})...`);

  // Prepare texts for embedding, clean slightly by replacing newlines
  const textsToEmbed = chunks.map(chunk => chunk.content.replace(/\n/g, " "));

  // Process texts in batches suitable for the API
  const batchSize = 100; // OpenAI generally handles larger batches, adjust if needed
  const allVectors: PineconeRecord<PineconeDocumentMetadata>[] = [];
  let totalEmbeddingsGenerated = 0;
  let totalTokensUsed = 0; // Optional: track token usage

  for (let i = 0; i < textsToEmbed.length; i += batchSize) {
    const textBatch = textsToEmbed.slice(i, i + batchSize);
    const chunkBatch = chunks.slice(i, i + batchSize); // Keep corresponding chunk objects
    console.log(`[OpenAI Embed Batch] Processing batch ${Math.floor(i / batchSize) + 1} of ${Math.ceil(textsToEmbed.length / batchSize)}, size: ${textBatch.length}`);

    try {
      // Call OpenAI API for the current batch
      const response = await openai.embeddings.create({
        model: OPENAI_EMBEDDING_MODEL,
        input: textBatch, // Send array of strings
        dimensions: EXPECTED_DIMENSION, // Request specific dimension
        encoding_format: "float", // Recommended format
      });

       // Log token usage (optional)
       if (response.usage) {
           console.log(`[OpenAI Embed Batch] Tokens used: Prompt=${response.usage.prompt_tokens}, Total=${response.usage.total_tokens}`);
           totalTokensUsed += response.usage.total_tokens;
       }

      // Validate response structure and length
      if (!response?.data || response.data.length !== textBatch.length) {
        // Log the actual response for debugging if possible
        console.error("[OpenAI Embed Batch] Embedding response length/structure mismatch.", { expected: textBatch.length, received: response?.data?.length });
        throw new Error(`OpenAI embedding response length mismatch in batch: expected ${textBatch.length}, got ${response?.data?.length ?? 0}`);
      }

      // Combine chunk metadata with the generated embeddings
      const batchVectors = chunkBatch.map((chunk, indexInBatch) => {
        const embeddingData = response.data[indexInBatch];

        // Validate individual embedding data
        if (!embeddingData?.embedding || !Array.isArray(embeddingData.embedding)) {
             console.warn(`[OpenAI Embed Batch] Invalid or missing embedding vector for chunk ${chunk.id} at index ${indexInBatch}. Skipping.`);
             return null; // Mark as invalid to filter out later
        }
         // Optional strict dimension check for each vector
         if (embeddingData.embedding.length !== EXPECTED_DIMENSION) {
             console.warn(`[OpenAI Embed Batch] Embedding dimension mismatch for chunk ${chunk.id}. Expected ${EXPECTED_DIMENSION}, got ${embeddingData.embedding.length}. Skipping.`);
             return null;
         }


        // Format metadata according to PineconeDocumentMetadata (strings for numbers)
        const metadataForPinecone: PineconeDocumentMetadata = {
          fileName: chunk.metadata.fileName,
          pageNumber: chunk.metadata.pageNumber?.toString(), // Number? to String | undefined
          chunkIndex: chunk.metadata.chunkIndex.toString(), // Number to String
          content: chunk.content, // Store original chunk content
          uploadedAt: new Date().toISOString(), // Add timestamp
        };

        // Create the record for Pinecone
        return {
          id: chunk.id, // Use the pre-generated chunk ID
          values: embeddingData.embedding, // Use the corresponding embedding
          metadata: metadataForPinecone,
        };
      });

      // Filter out any nulls that resulted from embedding errors
      const validBatchVectors = batchVectors.filter(v => v !== null) as PineconeRecord<PineconeDocumentMetadata>[];
      allVectors.push(...validBatchVectors);
      totalEmbeddingsGenerated += validBatchVectors.length; // Count only valid ones


    } catch (batchError) {
      console.error(`[OpenAI Embed Batch] Failed to process batch starting at index ${i}:`, batchError);
      // Stop processing entirely on batch failure to avoid partial uploads
      throw new Error(`Failed to process OpenAI embedding batch starting at index ${i}. Reason: ${batchError instanceof Error ? batchError.message : String(batchError)}`);
    }

  } // End batch loop

  console.log(`Finished generating ${totalEmbeddingsGenerated} total embedding records. Total tokens used (approx): ${totalTokensUsed}`);
  return allVectors;
}

// --- REMOVED Hugging Face IMPLEMENTATION and Mock Implementation ---// app/lib/document-utils.ts

// REMOVED: import { VectorDocument } from './embedding-utils'; // This caused the error
import { nanoid } from 'nanoid';

// --- Define VectorDocument interface LOCALLY ---
// This defines the structure returned by createVectorDocuments
export interface VectorDocument {
    id: string; // Now required, as nanoid() always provides one
    text: string; // The main content chunk
    // Define metadata structure created by createVectorDocuments
    metadata: {
        title: string;
        source: string;
        type: string;
        chunkIndex: number; // Added by createVectorDocuments
        totalChunks: number; // Added by createVectorDocuments
        // Include other potential fields passed in the input metadata object
        [key: string]: string | number | boolean | undefined;
    };
}
// --- End local definition ---


/**
 * Function to split text into chunks of manageable size
 * @param text Full text to be split
 * @param maxChunkSize Maximum characters per chunk
 * @param overlap Number of characters to overlap between chunks
 */
export function splitTextIntoChunks(
  text: string,
  maxChunkSize: number = 1000,
  overlap: number = 200
): string[] {
  // If text is already small enough, return as is
  if (!text || text.length <= maxChunkSize) {
    return text ? [text] : [];
  }

  const chunks: string[] = [];
  let startIndex = 0;

  while (startIndex < text.length) {
    // Calculate end index for current chunk
    let endIndex = Math.min(startIndex + maxChunkSize, text.length);

    // Adjust to avoid cutting words in the middle
    if (endIndex < text.length) {
      // Find the last space or newline in the current chunk
      const lastSpace = text.lastIndexOf(' ', endIndex);
      const lastNewline = text.lastIndexOf('\n', endIndex);

      // Use the closer one to the end
      const breakPoint = Math.max(lastSpace, lastNewline);

      // If no space or newline found, use the original endpoint
      // Ensure breakpoint is actually within the current intended chunk
      if (breakPoint > startIndex && breakPoint < endIndex) {
          endIndex = breakPoint;
      } else {
          // If no good break point, try moving back slightly less aggressively?
          // Or just take the maxChunkSize cut. For simplicity, we take the cut.
      }
    }

    // Extract chunk
    const chunk = text.substring(startIndex, endIndex).trim();
    if (chunk) { // Only add non-empty chunks
      chunks.push(chunk);
    }

    // Set next start index with overlap, ensure progress
    const nextStart = endIndex - overlap;
    // Prevent getting stuck if overlap is too large or chunks are tiny
    startIndex = Math.max(nextStart, startIndex + 1);

    // Safety break if somehow startIndex doesn't advance
    if (startIndex >= text.length) {
      break;
    }
  }

  return chunks;
}

/**
 * Create vector documents from text chunks using the locally defined VectorDocument type
 */
export function createVectorDocuments(
  chunks: string[],
  // Input metadata type can be more specific if needed
  metadata: {
    title: string;
    source: string;
    type: string;
    // Allow other passthrough fields
    [key: string]: string | number | boolean | undefined;
  }
): VectorDocument[] { // Function returns an array of the locally defined VectorDocument
  const totalChunks = chunks.length;
  return chunks.map((chunk, index) => ({
    id: nanoid(), // Generate a unique ID for each document/chunk object
    text: chunk, // The actual text chunk
    metadata: {
      ...metadata, // Spread the metadata provided as input
      chunkIndex: index, // Add the 0-based index of this chunk
      totalChunks: totalChunks, // Add the total number of chunks for this document
    },
  }));
}

/**
 * Extract text content from a file using FileReader (Browser environment only)
 * Basic implementation for .txt files
 * Note: This function will only work in a browser context, not in Node.js server-side code
 * unless you polyfill FileReader or use Node's fs module there.
 */
export async function extractTextFromFile(file: File): Promise<string> {
  // Check if running in a browser context where FileReader is available
  if (typeof FileReader === 'undefined') {
      return Promise.reject(new Error('FileReader API is not available in this environment. Cannot extract text.'));
  }

  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (event) => {
      // Ensure result is a string before resolving
      if (event.target?.result && typeof event.target.result === 'string') {
        resolve(event.target.result);
      } else {
        reject(new Error('Failed to read file content as text.'));
      }
    };

    reader.onerror = () => {
      // Provide the error from the reader if possible
      reject(new Error(`Error reading file: ${reader.error?.message || 'Unknown error'}`));
    };

    // Read as text. For non-text files, this will likely produce gibberish or fail.
    // Add checks for file type before calling this if necessary.
    if (file.type.startsWith('text/')) {
        reader.readAsText(file);
    } else {
         console.warn(`Attempting to read non-text file (${file.type}) as text. Content may be incorrect.`);
         reader.readAsText(file); // Proceed but warn
         // OR: reject(new Error(`Unsupported file type for text extraction: ${file.type}`));
    }
  });
}// app/lib/registry.tsx
'use client';

import React, { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import { ServerStyleSheet, StyleSheetManager } from 'styled-components';

export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode;
}) {
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement();
    styledComponentsStyleSheet.instance.clearTag();
    return <>{styles}</>;
  });

  if (typeof window !== 'undefined') return <>{children}</>;

  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  );
}import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import pdfParse from 'pdf-parse';
import mammoth from 'mammoth';

/**
 * Write file to temporary directory
 */
export async function writeFileToTemp(
  buffer: ArrayBuffer, 
  filename: string
): Promise<string> {
  // Create a temporary directory
  const tempDir = await fs.mkdtemp(
    path.join(os.tmpdir(), 'macbot-upload-')
  );
  
  // Create file path
  const filePath = path.join(tempDir, filename);
  
  // Write the file
  await fs.writeFile(
    filePath, 
    Buffer.from(buffer)
  );
  
  return filePath;
}

/**
 * Clean up temporary file
 */
export async function cleanupTempFile(filePath: string): Promise<void> {
  try {
    // Check if the file exists
    await fs.access(filePath);
    
    // Delete the file
    await fs.unlink(filePath);
    
    // Try to remove the directory
    const dirPath = path.dirname(filePath);
    await fs.rmdir(dirPath);
  } catch (error) {
    console.error('Error cleaning up temp file:', error);
    // Continue even if cleanup fails
  }
}

/**
 * Parse text file
 */
export async function parseTextFile(filePath: string): Promise<string> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return content;
  } catch (error) {
    console.error('Error parsing text file:', error);
    throw new Error('Failed to parse text file');
  }
}

/**
 * Parse PDF file
 */
export async function parsePdfFile(filePath: string): Promise<string> {
  try {
    const dataBuffer = await fs.readFile(filePath);
    const pdfData = await pdfParse(dataBuffer);
    return pdfData.text;
  } catch (error) {
    console.error('Error parsing PDF file:', error);
    throw new Error('Failed to parse PDF file');
  }
}

/**
 * Parse DOCX file
 */
export async function parseDocxFile(filePath: string): Promise<string> {
  try {
    const buffer = await fs.readFile(filePath);
    const result = await mammoth.extractRawText({ buffer });
    return result.value;
  } catch (error) {
    console.error('Error parsing DOCX file:', error);
    throw new Error('Failed to parse DOCX file');
  }
}

/**
 * Detect file type from extension and parse accordingly
 */
export async function parseFile(
  buffer: ArrayBuffer,
  filename: string
): Promise<string> {
  // Get file extension
  const ext = path.extname(filename).toLowerCase();
  
  // Write to temp file
  const filePath = await writeFileToTemp(buffer, filename);
  
  try {
    // Process based on file type
    if (ext === '.txt' || ext === '.md') {
      return await parseTextFile(filePath);
    } else if (ext === '.pdf') {
      return await parsePdfFile(filePath);
    } else if (ext === '.docx' || ext === '.doc') {
      return await parseDocxFile(filePath);
    } else {
      throw new Error(`Unsupported file type: ${ext}`);
    }
  } finally {
    // Clean up temp file
    await cleanupTempFile(filePath);
  }
}// app/lib/openrouter-client.ts
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_SITE_URL = process.env.OPENROUTER_SITE_URL || 'https://macbot-app.vercel.app';
const OPENROUTER_SITE_NAME = process.env.OPENROUTER_SITE_NAME || 'MacBot Shakespeare Assistant';

// Check if the API key is defined
if (!OPENROUTER_API_KEY) {
  console.error("Missing OPENROUTER_API_KEY environment variable");
}

// Default model configuration
export const modelName = "x-ai/grok-3-mini-beta";

// Basic headers required for OpenRouter
export const openRouterHeaders = {
  "Authorization": `Bearer ${OPENROUTER_API_KEY}`,
  "HTTP-Referer": OPENROUTER_SITE_URL,
  "X-Title": OPENROUTER_SITE_NAME,
  "Content-Type": "application/json"
};

// Base URL for OpenRouter API
export const OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions";

// Basic streaming request function
export async function streamCompletion(messages: Array<{role: string, content: string}>) {
  if (!OPENROUTER_API_KEY) {
    throw new Error("OpenRouter API key is not configured");
  }
  
  return fetch(OPENROUTER_API_URL, {
    method: "POST",
    headers: {
      ...openRouterHeaders,
      "Accept": "text/event-stream",
    },
    body: JSON.stringify({
      model: modelName,
      messages,
      stream: true,
      temperature: 0.7,
      max_tokens: 4000,
    }),
  });
}

export default {
  streamCompletion,
  headers: openRouterHeaders,
  modelName,
};// app/api/chat/route.ts
import { NextResponse } from 'next/server';
import { streamCompletion, modelName } from '@/app/lib/openrouter-client';
import { querySimilarChunks } from '@/app/lib/pinecone-client';
import { generateEmbedding } from '@/app/lib/embedding-utils';
import { Message, VectorSearchResult } from '@/app/types';

export async function POST(req: Request) {
  console.log('--- /api/chat endpoint hit ---');
  try {
    const { messages, useUploadedFiles }: { messages: Message[], useUploadedFiles?: boolean } = await req.json();

    if (!messages || !Array.isArray(messages)) {
      console.error("Invalid request: 'messages' array not found.");
      return NextResponse.json({ error: 'Invalid request format' }, { status: 400 });
    }
    console.log(`Received ${messages.length} messages. useUploadedFiles: ${useUploadedFiles}`);

    let retrievedContextText = '';
    let retrievedChunks: VectorSearchResult[] = [];

    // RAG Process: Same as before
    const latestUserMessage = messages.findLast((msg) => msg.role === 'user');

    if (latestUserMessage?.content) {
      console.log(`[RAG] Attempting RAG for query:`, latestUserMessage.content.substring(0, 100) + "...");
      try {
        const queryEmbeddingVector = await generateEmbedding(latestUserMessage.content);
        console.log("[RAG] Query embedding generated.");

        if (queryEmbeddingVector && queryEmbeddingVector.length > 0) {
          console.log("[RAG] Querying Pinecone for similar chunks...");
          retrievedChunks = await querySimilarChunks(
            queryEmbeddingVector,
            3 // Retrieve top 3 chunks
          );
          console.log(`[RAG] Retrieved ${retrievedChunks.length} chunks from Pinecone.`);

          if (retrievedChunks.length > 0) {
            retrievedContextText = `--- START CONTEXT FROM UPLOADED DOCUMENTS ---\n${
              retrievedChunks.map((chunk, idx) =>
                `[Context Chunk ${idx + 1} | Source: ${chunk.metadata.fileName} | Chunk Index: ${chunk.metadata.chunkIndex}]\n${chunk.content}`
              ).join('\n\n---\n\n')
            }\n--- END CONTEXT FROM UPLOADED DOCUMENTS ---`;
            console.log('[RAG] Formatted Context Text Prepared.');
          } else {
            console.log("[RAG] No relevant chunks found in Pinecone.");
          }
        } else {
          console.log("[RAG] Skipping Pinecone query due to invalid/empty embedding vector.");
        }
      } catch (ragError) {
        console.error("[RAG] Error during RAG retrieval/embedding:", ragError);
        retrievedContextText = '';
      }
    }

    // Prepare Messages Array for LLM (same as before)
    const messagesForLLM = messages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));

    // System prompt logic (same as before)
    const systemPromptIndex = messagesForLLM.findIndex(msg => msg.role === 'system');
    const baseSystemPrompt = "You are Macbot, an AI assistant specialized in helping students understand Shakespeare's Macbeth. You can explain themes, characters, plot points, literary devices, and historical context. Your responses should be educational, clear, and engaging. When appropriate, cite specific acts, scenes, and lines from the play. If you don't know an answer, admit that rather than making up information. Always maintain an educational and supportive tone.";
    const contextInstruction = "\n\nIMPORTANT: If relevant context from uploaded documents is provided in a subsequent system message, prioritize using that information to answer the user's query. Base your response primarily on the provided document context if it's relevant.";

    if (systemPromptIndex !== -1) {
      messagesForLLM[systemPromptIndex].content = baseSystemPrompt + contextInstruction;
    } else {
      messagesForLLM.unshift({ role: 'system', content: baseSystemPrompt + contextInstruction });
    }

    // Inject Retrieved Context (same logic as before)
    if (retrievedContextText) {
      const lastUserMessageIndex = messagesForLLM.findLastIndex((msg) => msg.role === 'user');
      if (lastUserMessageIndex !== -1) {
        messagesForLLM.splice(lastUserMessageIndex, 0, {
          role: 'system',
          content: `Use the following context to answer the user's question:\n${retrievedContextText}`
        });
        console.log("[Prompt Injection] Injected retrieved context as system message.");
      } else if (systemPromptIndex !== -1) {
        messagesForLLM[systemPromptIndex].content += `\n\nRetrieved Context:\n${retrievedContextText}`;
        console.log("[Prompt Injection] Appended context to main system prompt (fallback).");
      }
    }

    console.log(`\n--- Sending ${messagesForLLM.length} Messages to LLM (${modelName}) ---`);
    console.log(JSON.stringify(messagesForLLM, null, 2));
    console.log('--- End LLM Payload ---\n');

    // === CHANGED: Using OpenRouter instead of Together.ai ===
    const response = await streamCompletion(messagesForLLM);
    
    if (!response.ok) {
      const error = await response.text();
      console.error("OpenRouter API error:", error);
      throw new Error(`OpenRouter API error: ${error}`);
    }
    
    console.log("Received stream response from OpenRouter.");

    // === CHANGED: Stream handling for OpenRouter format ===
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        const reader = response.body?.getReader();
        
        if (!reader) {
          controller.error(new Error("Failed to get reader from response"));
          return;
        }
        
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            
            // Convert the chunk to text
            const chunk = new TextDecoder().decode(value);
            
            // Process SSE format - handle multiple events in a chunk
            const events = chunk
              .split('\n\n')
              .filter(line => line.trim() !== '' && line.trim() !== 'data: [DONE]');
            
            for (const event of events) {
              // Extract JSON data from "data: {json}" format
              const jsonMatch = event.match(/data: (.+)$/m);
              if (!jsonMatch) continue;
              
              try {
                const jsonData = JSON.parse(jsonMatch[1]);
                const content = jsonData.choices?.[0]?.delta?.content || '';
                
                if (content) {
                  controller.enqueue(encoder.encode(content));
                }
              } catch (e) {
                console.error("Error parsing chunk:", e);
              }
            }
          }
        } catch (error) {
          console.error("Streaming error from OpenRouter:", error);
          controller.error(error);
        } finally {
          console.log("LLM response stream finished.");
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });

  } catch (error: unknown) {
    console.error('--- Error in chat API route ---:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown server error occurred.';
    return NextResponse.json(
      { error: `Failed to generate response: ${errorMessage}` },
      { status: 500 }
    );
  }
}// app/api/admin/upload-document/route.ts
import { NextResponse } from 'next/server';
import { nanoid } from 'nanoid';
import { generateEmbeddings } from '@/app/lib/embeddings';
import { insertVectors } from '@/app/lib/pinecone-client';
import { FileChunk } from '@/app/types';

interface UploadMetadata {
    title: string;
    source: string;
    type: string;
}

export async function POST(req: Request) {
  console.log('--- /api/admin/upload-document endpoint hit ---');
  try {
    const formData = await req.formData();
    const file = formData.get('file') as File | null;
    const metadataString = formData.get('metadata') as string | null;

    // Validation logic
    if (!file || !(file instanceof File) || !metadataString) {
      return NextResponse.json(
        { error: 'Invalid file or missing metadata' },
        { status: 400 }
      );
    }
    
    let parsedMetadata: UploadMetadata;
    try {
      parsedMetadata = JSON.parse(metadataString) as UploadMetadata;
      if (!parsedMetadata.title) {
        return NextResponse.json({ error: 'Metadata is missing required "title" field' }, { status: 400 });
      }
    } catch {
      return NextResponse.json({ error: 'Invalid metadata format. Must be valid JSON.' }, { status: 400 });
    }

    const fileId = nanoid(10);
    const originalFileName = file.name;
    console.log(`Processing file: ${originalFileName} (size: ${file.size} bytes) with ID: ${fileId}`);

    // Extract text directly from buffer
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    
    let fileContent = '';
    const fileExt = file.name.toLowerCase().split('.').pop() || '';
    
    try {
      if (fileExt === 'txt' || fileExt === 'md') {
        fileContent = buffer.toString('utf-8');
      
      } else if (fileExt === 'pdf') {
        // Parse PDF using pdf-parse with specific options to avoid test file access
        try {
          const pdfParse = await import('pdf-parse');
          
          // Be explicit with options to prevent test file access
          const options = {
            // These options help avoid default behaviors
            max: 0,           // Don't limit pages
            version: '1.10.100',  // Set a specific PDF version
            pagerender: null, // Don't use custom page renderer
            password: ''      // No password
          };
          
          const pdfData = await (pdfParse.default)(buffer, options);
          fileContent = pdfData.text;
          console.log(`Extracted ${fileContent.length} characters from PDF`);
        } catch (error) {
          console.error('PDF parsing error:', error);
          // If the error is related to test files, provide a clearer message
          if (error instanceof Error && error.message.includes('ENOENT')) {
            throw new Error('PDF parsing error: The library is trying to access test files. This is a known issue with the pdf-parse library.');
          } else {
            throw new Error(`Failed to parse PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        }
      } else if (fileExt === 'docx' || fileExt === 'doc') {
        // Parse DOCX using mammoth
        try {
          const mammoth = await import('mammoth');
          const result = await mammoth.extractRawText({ buffer });
          fileContent = result.value;
          console.log(`Extracted ${fileContent.length} characters from Word document`);
        } catch (error) {
          console.error('DOCX parsing error:', error);
          throw new Error(`Failed to parse Word document: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      } else {
        return NextResponse.json({ error: `Unsupported file type: .${fileExt}` }, { status: 400 });
      }
    } catch (error) {
      console.error(`Error parsing ${fileExt} file:`, error);
      return NextResponse.json({ 
        error: `Failed to parse ${fileExt.toUpperCase()} file`, 
        details: error instanceof Error ? error.message : 'Unknown error' 
      }, { status: 500 });
    }

    if (!fileContent) {
      return NextResponse.json({ error: 'Empty file content' }, { status: 400 });
    }

    // Split content into chunks
    const chunkSize = 1000;
    const overlap = 200;
    const fileChunks: FileChunk[] = [];
    
    for (let i = 0; i < fileContent.length; i += (chunkSize - overlap)) {
      const chunkEnd = Math.min(i + chunkSize, fileContent.length);
      const chunkContent = fileContent.slice(i, chunkEnd).trim();
      if (chunkContent) {
        fileChunks.push({
          id: `${fileId}-chunk-${fileChunks.length}`,
          fileId: fileId,
          content: chunkContent,
          metadata: {
            fileName: originalFileName,
            chunkIndex: fileChunks.length,
            pageNumber: undefined,
          },
        });
      }
    }

    if (fileChunks.length === 0) {
      return NextResponse.json({ error: 'No chunks could be generated from file' }, { status: 400 });
    }

    // Generate embeddings and store in Pinecone
    const vectors = await generateEmbeddings(fileChunks);
    if (!vectors || vectors.length === 0) {
      return NextResponse.json({ error: 'Failed to generate embeddings' }, { status: 500 });
    }
    
    await insertVectors(vectors);

    return NextResponse.json({
      success: true,
      message: `Document "${parsedMetadata.title}" (${originalFileName}) processed successfully with ${fileChunks.length} chunks.`,
      fileName: originalFileName,
      chunks: fileChunks.length,
    });

  } catch (error) {
    console.error('--- ERROR in /api/admin/upload-document ---:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown server error occurred.';
    return NextResponse.json(
      { error: 'Failed to process document upload due to a server error.', details: errorMessage },
      { status: 500 }
    );
  }
}// app/api/documents/route.ts
import { NextResponse } from 'next/server';
import { getIndex } from '@/app/lib/pinecone-client';

export async function GET(req: Request) {
  try {
    // Get the URL params
    const url = new URL(req.url);
    const limit = parseInt(url.searchParams.get('limit') || '10');
    
    // Get Pinecone index
    const index = await getIndex();
    
    // Get index stats to determine dimension
    const stats = await index.describeIndexStats();
    
    // Create a dummy vector query to fetch documents
    const dummyVector = Array(stats.dimension).fill(0);
    
    // Fetch document metadata using a query
    const response = await index.query({ 
      vector: dummyVector,
      topK: limit,
      includeMetadata: true
    });
    
    // Extract document information from matches
    const documents = response.matches.map(match => ({
      id: match.id,
      fileName: match.metadata?.fileName,
      uploadedAt: match.metadata?.uploadedAt,
    }));
    
    // Group documents by file name
    const groupedDocuments: Record<string, { 
      fileName: string; 
      uploadedAt?: string;
      chunks: number;
    }> = {};
    
    documents.forEach(doc => {
      if (doc.fileName) {
        const fileName = doc.fileName as string;
        if (!groupedDocuments[fileName]) {
          groupedDocuments[fileName] = {
            fileName: fileName,
            uploadedAt: doc.uploadedAt as string | undefined,
            chunks: 0
          };
        }
        groupedDocuments[fileName].chunks++;
      }
    });
    
    return NextResponse.json({
      documents: Object.values(groupedDocuments)
    });
  } catch (error) {
    console.error('Error fetching documents:', error);
    return NextResponse.json(
      { error: 'Failed to fetch documents' },
      { status: 500 }
    );
  }
}

export async function DELETE(req: Request) {
  try {
    // Get the request body
    const { fileName } = await req.json();
    
    if (!fileName) {
      return NextResponse.json(
        { error: 'File name is required' },
        { status: 400 }
      );
    }
    
    // Get Pinecone index
    const index = await getIndex();
    
    // Get index dimension for query
    const stats = await index.describeIndexStats();
    const dummyVector = Array(stats.dimension).fill(0);
    
    // Query vectors by fileName to get IDs
    const queryResponse = await index.query({
      vector: dummyVector,
      topK: 1000,
      includeMetadata: true,
      filter: {
        fileName: { $eq: fileName }
      }
    });
    
    // Get IDs to delete
    const idsToDelete = queryResponse.matches.map(match => match.id);
    
    if (idsToDelete.length > 0) {
      // Delete vectors in batches
      const batchSize = 100;
      for (let i = 0; i < idsToDelete.length; i += batchSize) {
        const batch = idsToDelete.slice(i, i + batchSize);
        await index.deleteMany(batch);
      }
    }
    
    return NextResponse.json({
      success: true,
      deletedCount: idsToDelete.length,
      fileName
    });
  } catch (error) {
    console.error('Error deleting document:', error);
    return NextResponse.json(
      { error: 'Failed to delete document' },
      { status: 500 }
    );
  }
}// app/api/upload/route.ts
import { NextResponse } from 'next/server';
import * as path from 'path'; // Keep for extname
import { nanoid } from 'nanoid';

// Import embedding generation and Pinecone client
import { generateEmbeddings } from '@/app/lib/embeddings';
import { insertVectors } from '@/app/lib/pinecone-client';
import { FileChunk } from '@/app/types';

export async function POST(req: Request) {
  console.log('--- /api/upload endpoint hit ---');
  try {
    console.log('Attempting to read formData...');
    const formData = await req.formData();
    console.log('FormData read successfully.');

    const filesKey = 'files';
    console.log(`Attempting to get files using key: '${filesKey}'...`);
    const files = formData.getAll(filesKey) as File[];
    console.log(`Received ${files?.length ?? 'undefined/null'} file(s) under key '${filesKey}'`);

    if (!files || files.length === 0) {
      console.log(`Validation failed: No files found in formData for key '${filesKey}'. Returning 400.`);
      return NextResponse.json(
        { error: `No files uploaded under the key '${filesKey}'` },
        { status: 400 }
      );
    }

    console.log(`Found ${files.length} file(s). Starting processing loop...`);
    const fileNames: string[] = [];
    const processedFilesInfo: Array<{ name: string; chunks: number }> = [];

    for (const file of files) {
      if (!(file instanceof File)) {
          console.warn("Received an item in formData that is not a File object, skipping:", file);
          continue;
      }

      const fileId = nanoid(10);
      const originalFileName = file.name;
      fileNames.push(originalFileName);
      console.log(`Processing file: ${originalFileName} (size: ${file.size} bytes) with ID: ${fileId}`);

      // --- Process Buffer Directly ---
      console.log(`Reading buffer for file: ${originalFileName}`);
      const arrayBuffer = await file.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      console.log(`Buffer read successfully (size: ${buffer.length})`);

      // --- Extract Text (using the buffer directly) ---
      let fileContent = '';
      const fileExt = path.extname(originalFileName).toLowerCase();
      console.log(`Extracting content for type: ${fileExt}`);

      try {
        if (fileExt === '.txt' || fileExt === '.md') {
          fileContent = buffer.toString('utf-8');
        } else if (fileExt === '.pdf') {
          // Parse PDF using pdf-parse with proper typing
          try {
            const pdfParseModule = await import('pdf-parse');
            const pdfParse: (buffer: Buffer, options?: object) => Promise<{ text: string }> = pdfParseModule.default;
            const pdfData = await pdfParse(buffer, {});
            fileContent = pdfData.text;
            console.log(`Extracted ${fileContent.length} characters from PDF`);
          } catch (error) {
            console.error('PDF parsing error:', error);
            throw new Error(`Failed to parse PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        } else if (fileExt === '.docx' || fileExt === '.doc') {
          // Parse DOCX using mammoth
          try {
            const mammoth = await import('mammoth');
            const result = await mammoth.extractRawText({ buffer });
            fileContent = result.value;
            console.log(`Extracted ${fileContent.length} characters from Word document`);
          } catch (error) {
            console.error('DOCX parsing error:', error);
            throw new Error(`Failed to parse Word document: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        } else {
          console.warn(`Unsupported file type '${fileExt}' for content extraction. Skipping content processing for ${originalFileName}.`);
          continue; // Skip this file if type is unsupported
        }
      } catch (error) {
        console.error(`Error parsing file ${originalFileName}:`, error);
        // Continue with next file on error
        continue;
      }
      
      console.log(`Content extracted (length: ${fileContent?.length || 0})`);

      // --- Split into Chunks ---
      if (!fileContent) {
          console.warn(`No content available for ${originalFileName}, skipping chunking and embedding.`);
          continue;
      }
      const chunkSize = 1000;
      const overlap = 200;
      const fileChunks: FileChunk[] = [];
      console.log(`Splitting into chunks (size: ${chunkSize}, overlap: ${overlap})...`);
      for (let i = 0; i < fileContent.length; i += (chunkSize - overlap)) {
        const chunkEnd = Math.min(i + chunkSize, fileContent.length);
        // Ensure chunkContent is derived correctly after removing intermediate variables
        const chunkContent = fileContent.slice(i, chunkEnd).trim();
        if (chunkContent) { // Only add non-empty chunks
            fileChunks.push({
              id: `${fileId}-chunk-${fileChunks.length}`,
              fileId: fileId,
              content: chunkContent, // Use the trimmed chunk content
              metadata: {
                fileName: originalFileName,
                chunkIndex: fileChunks.length,
                pageNumber: undefined,
              },
            });
        }
      }
      console.log(`Generated ${fileChunks.length} chunks.`);

      if (fileChunks.length === 0) {
          console.warn(`No chunks generated for ${originalFileName}, skipping embedding.`);
          continue;
      }

      // --- Generate Embeddings ---
      const vectors = await generateEmbeddings(fileChunks); // Assumes this returns the correct format

      // --- Upsert into Pinecone ---
      if (vectors && vectors.length > 0) {
        await insertVectors(vectors); // Assumes this handles Pinecone interaction
        processedFilesInfo.push({ name: originalFileName, chunks: fileChunks.length });
      } else {
          console.warn(`No vectors generated for ${originalFileName}.`);
      }
    } // End of loop through files

    console.log('--- /api/upload processing successful ---');
    return NextResponse.json({
      success: true,
      message: `${processedFilesInfo.length} file(s) processed successfully.`,
      processedFiles: processedFilesInfo,
    });

  } catch (error) {
    console.error('--- ERROR in /api/upload ---:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown server error occurred.';
    return NextResponse.json(
      { error: 'Failed to process upload due to a server error.', details: errorMessage },
      { status: 500 }
    );
  }
}// app/page.tsx
'use client';

import Chat from './components/Chat';
import Link from 'next/link';
import styled from 'styled-components';

// Add padding and dramatic styling to the main container
const PageContainer = styled.main`
  display: flex;
  min-height: 100vh;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  background-color: ${props => props.theme?.colors?.background || 'var(--background)'};
  background-image: url('/parchment-bg.png');
  background-size: cover;
  background-attachment: fixed;
  position: relative; /* Add position relative for absolute positioning inside */
`;

const ContentWrapper = styled.div`
  width: 100%;
  max-width: 800px;
  position: relative;
  margin: 2rem auto;
`;

// Redesigned admin button with more prominent styling
const AdminButton = styled.div`
  position: absolute;
  top: 1.5rem;
  right: 1.5rem;
  z-index: 10;
  
  a {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.6rem 1rem;
    background-color: ${props => props.theme?.colors?.backgroundDark || '#e8dfc2'};
    color: ${props => props.theme?.colors?.primary || '#3a1e1c'};
    font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
    font-weight: 500;
    font-size: 0.9rem;
    border: 1px solid ${props => props.theme?.colors?.border || '#59321f'};
    border-radius: ${props => props.theme?.borderRadius?.medium || '8px'};
    text-decoration: none;
    box-shadow: ${props => props.theme?.shadows?.small || '0 2px 4px rgba(0, 0, 0, 0.1)'};
    transition: all 0.2s ease;
    
    &:before {
      content: '✒️';
      margin-right: 0.5rem;
      font-size: 1.2rem;
    }
    
    &:hover {
      background-color: ${props => props.theme?.colors?.gold || '#c4a747'};
      border-color: ${props => props.theme?.colors?.primaryDark || '#2a1615'};
      color: ${props => props.theme?.colors?.primaryDark || '#2a1615'};
      box-shadow: ${props => props.theme?.shadows?.medium || '0 4px 8px rgba(0, 0, 0, 0.2)'};
      transform: translateY(-2px);
    }
    
    &:active {
      transform: translateY(0);
      box-shadow: ${props => props.theme?.shadows?.small || '0 2px 4px rgba(0, 0, 0, 0.1)'};
    }
  }
`;

// Dramatic heading styles
const Title = styled.h1`
  text-align: center;
  font-size: 3rem;
  margin-bottom: 0.5rem;
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  color: ${props => props.theme?.colors?.primary || 'var(--foreground)'};
  text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
  
  &:before, &:after {
    content: '✧';
    font-size: 2rem;
    margin: 0 1rem;
    color: ${props => props.theme?.colors?.gold || '#c4a747'};
    vertical-align: middle;
  }
`;

const Subtitle = styled.h2`
  text-align: center;
  font-size: 1.5rem;
  margin-bottom: 2rem;
  font-family: ${props => props.theme?.fonts?.heading || 'inherit'};
  font-style: italic;
  color: ${props => props.theme?.colors?.textLight || 'var(--foreground)'};
  
  &:before, &:after {
    content: '~';
    margin: 0 0.5rem;
    color: ${props => props.theme?.colors?.secondary || 'var(--primary)'};
  }
`;

const Flourish = styled.div`
  text-align: center;
  margin: 1rem 0;
  font-size: 1.5rem;
  color: ${props => props.theme?.colors?.gold || '#c4a747'};
`;

export default function Home() {
  return (
    <PageContainer>
      <AdminButton>
        <Link href="/admin">Scribe&apos;s Chambers</Link>
      </AdminButton>
      
      <ContentWrapper>
        <Title>The Macbeth Oracle</Title>
        <Subtitle>A Digital Companion for the Scottish Play</Subtitle>
        
        <Flourish>❦ ❦ ❦</Flourish>
        
        <Chat />
        
        <Flourish>❦ ❦ ❦</Flourish>
      </ContentWrapper>
    </PageContainer>
  );
}:root {
    --foreground: #000;
    --background: #fff;
    --primary: #0070f3;
    --primary-hover: #0051a2;
    --gray-100: #f3f4f6;
    --gray-200: #e5e7eb;
    --gray-300: #d1d5db;
    --gray-800: #1f2937;
  }
  
  @media (prefers-color-scheme: dark) {
    :root {
      --foreground: #fff;
      --background: #121212;
      --gray-100: #1f2937;
      --gray-200: #374151;
      --gray-300: #4b5563;
      --gray-800: #e5e7eb;
    }
  }
  
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }
  
  html,
  body {
    max-width: 100vw;
    height: 100%;
    overflow-x: hidden;
  }
  
  body {
    color: var(--foreground);
    background: var(--background);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen,
      Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  }
  
  a {
    color: inherit;
    text-decoration: none;
  }